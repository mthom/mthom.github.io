((3) 0 () 1 ((p+ #"/home/mark/Projects/Shen/shen-blog/_src/posts/2015-06-08-shen-kata-1-type-safe-reference-cells.md" . unix)) () (h ! (equal) ((? . 0) f post (u . "Shen Kata #1: Type-safe reference cells") (? . 0) 1433863644 (p+ #"/home/mark/Projects/Shen/shen-blog/blog/2015/06/08/shen-kata-1-type-safe-reference-cells/index.html" . unix) "/blog/2015/06/08/shen-kata-1-type-safe-reference-cells/" (u . "2015-06-08T19:38:12") #f #f (c (u . "shen") c (u . "currying") c (u . "reference cells") c (u . "types") c (u . "vectors")) (u . "\n<p>Unlike many other eager, statically typed functional languages that emphasize computing with immutable values, Shen lacks native support for reference cells. Let&rsquo;s add our own.</p>") #t (u . "\n<p>Unlike many other eager, statically typed functional languages that emphasize computing with immutable values, Shen lacks native support for reference cells. Let&rsquo;s add our own.</p>\n<!-- more-->\n\n<h2 id=\"first-class-locally-scoped-mutable-values\">First-class, locally scoped mutable values</h2>\n\n<p>We can think of a reference cell as a box containing a pointer to a value of any initial type. In ML family languages, reference cells are associated to interfaces similar to that of the Standard ML signature</p>\n\n<pre><code>signature REF =\nsig \n  type 'a ref\n  val ref : 'a -&gt; 'a ref\n  val writeref : 'a ref -&gt; 'a -&gt; ()\n  val readref : 'a ref -&gt; 'a\nend</code></pre>\n\n<p><code>'a ref</code> is the type of a reference cell, where the ML type <code>'a</code> is the type of its contents. <code>ref</code> creates a reference cell containing its parameter value, <code>writeref</code> replaces the contents of a reference cell with a value of the annotated type of that cell, and <code>readref</code> extracts the contents of a cell.</p>\n\n<p>A write made to a reference cell is propagated to all other data structures containing that cell, which is itself an immutable value. In that sense, reference cells are first-class, locally scoped mutable values of the sort we&rsquo;re accustomed to using in imperative languages.</p>\n\n<p>As in imperative languages, they require a kind of temporal reasoning that is safely neglected when dealing only with immutable values, which is one of the stronger selling points of purely functional languages.</p>\n\n<p>Why bother with reference cells then? At times, the use of mutation can&rsquo;t be avoided, usually for the sake of efficiency. Some data structures lack fast, purely functional implementations. Others are self-referential and can&rsquo;t otherwise be implemented without resorting to laziness, which comes with its own pitfalls and limitations.</p>\n\n<h2 id=\"shen-lacks-reference-cells\">Shen lacks reference cells</h2>\n\n<p>If Shen provided reference cells natively, there would be no reason to add our own. Any candidate for an ad-hoc reference cell in Shen would have to support mutation already. Shen provides mutable values in two principal ways, through vectors and through global assignments.</p>\n\n<p>Global assignments are not locally scoped, since they&rsquo;re accessible from anywhere in a Shen program if the name of the assignment is known.</p>\n\n<p>Shen vectors are first-class, mutable, homogenous containers with a native type theory in line with what we want for ref types, apeing the example of ML. Vectors have the additional property that they may be grown and shrunk an element at a time from the head. In contrast, a reference cell must refer to a single location in memory that persists with the cell, which is to say that an unfettered vector representation allows the programmer to violate core semantic assumptions behind the creation and use of reference cells.</p>\n\n<h2 id=\"a-shen-implementation\">A Shen implementation</h2>\n\n<p>This suggests we should start with vectors as a data representation, and constrain them somehow. One approach is to close two functions over a single cell vector containing an initial value of type <code>A</code>. This prevents the user of the reference cell from accessing the internal vector representation by any means other than that afforded by the two functions, which we will implement as a getter/setter pair. Following the types in the ML signature, we obtain type signatures for these functions,</p>\n\n<p>the getter, <code>ref-reader : (one-cell-vector A) --&gt; (lazy A)</code></p>\n\n<p>and the setter, <code>ref-writer : (one-cell-vector A) --&gt; A --&gt; unit</code>.</p>\n\n<p><code>ref-reader</code>, given a one-cell vector, returns a value of type <code>(lazy\nA)</code>, whose semantics are identical to a function that takes no arguments.</p>\n\n<p><code>ref-writer</code> writes a value of type <code>A</code> to a one-cell vector.</p>\n\n<p>Natively, Shen has a vector type <code>(vector A)</code>, which types a vector of elements of type <code>A</code>. We have to define the <code>(one-cell-vector A)</code> type ourselves, which we do using the sequent rules</p>\n\n<pre><code> (datatype one-cell-vector\n   X : A;\n   ________________________________\n   (@v X &lt;&gt;) : (one-cell-vector A);\n\n   __________________________________________\n   V : (one-cell-vector A) &gt;&gt; V : (vector A);)</code></pre>\n\n<p>Here we give two rules of inference. The first says that a Shen expression matching the template <code>(@v X &lt;&gt;)</code> can be inferred to be of type <code>(one-cell-vector A)</code> if the subexpression <code>X</code> can be inferred to be of type <code>A</code>, where <code>A</code> is a type variable and hence may be substituted for any Shen type (type symbols titled in lower case name concrete types).</p>\n\n<p>The second rule is subtly different. It says that, if it has been proven that a Shen expression <code>V</code> is of type <code>(one-cell-vector A)</code>, (really, <code>V</code> is a template that may be substituted for any Shen expression), then <code>V</code> has the type <code>(vector A)</code>.</p>\n\n<p>These rules stringently constrain the number of ways in which we can generate elements of <code>(one-cell-vector A)</code>. Either we&rsquo;ve called a type-checked function that returns a value of that type, or we&rsquo;ve generated one directly using the <code>(@v X &lt;&gt;)</code> template, where <code>X</code> is an expression producing a value of type <code>A</code>. We could easily enrich the type theory to allow other semantically valid ways of generating one cell vectors, but for our purposes these rules suffice.</p>\n\n<p>The unit type is pre-defined in Shen, and is uninhabited (no values have the type unit by default). We add our own.</p>\n\n<pre><code>(datatype unit-type\n __________\n [] : unit;)</code></pre>\n\n<p>Equipped with the necessary types, we define the <code>ref-reader</code> and <code>ref-writer</code> functions.</p>\n\n<pre><code>(define ref-reader\n  { (one-cell-vector A) --&gt; (lazy A) } \n  R -&gt; (freeze (&lt;-vector R 1)))\n\n(define ref-writer\n  { (one-cell-vector A) --&gt; A --&gt; unit }\n  R X -&gt; (do (vector-&gt; R 1 X) []))</code></pre>\n\n<p><code>ref-reader</code> suspends (&ldquo;freezes&rdquo;) a computation on a one cell vector <code>R</code>, which reads the value of that cell whenever the computation is thawed (Shen vectors are 1-indexed).</p>\n\n<p><code>ref-writer</code> sequences two expressions in a <code>do</code> form. The first writes the value <code>X</code> to the cell of <code>R</code>, the second evaluates to unit.</p>\n\n<p>We now implement <code>ref</code>, again in keeping with the type given in the ML signature.</p>\n\n<pre><code>(define ref\n   { A --&gt; (ref A) }\n   X -&gt; (let V (@v X &lt;&gt;)\n\t  (@p (ref-reader V) (ref-writer V))))</code></pre>\n\n<p>In Shen, all functions are curried by default, so that the function <code>(ref-writer V)</code> has type <code>A --&gt; unit</code>. <code>(ref A)</code> is defined in the datatype</p>\n\n<pre><code>(datatype ref-types\n   V : (one-cell-vector A);\n   _____________________________________________\n   (@p (ref-reader V) (ref-writer V)) : (ref A);\n\n   _____________________________________________\n   R : (ref A) &gt;&gt; R : ((lazy A) * (A --&gt; unit));)</code></pre>\n\n<p>Since in the context of the definition of <code>ref</code>, we can prove that the expression bound to <code>V</code> is a one-cell vector, it follows by the first rule that the ordered pair <code>(@p (ref-reader V) (ref-writer V))</code> inhabits the type <code>(ref A)</code>.</p>\n\n<p>The second rule says that a value <code>R</code> known to be of type <code>(ref A)</code> is an ordered pair in which the first element has type <code>(lazy A)</code> and the second type <code>(A --&gt; unit)</code>.</p>\n\n<p>And that is all. The type rules guarantee that any value proved to be of type <code>(ref A)</code> is an ordered pair of the reader and writer types, closing over a common one-cell vector, where the reader and writer functions are generated using the <code>ref-reader</code> and <code>ref-writer</code> functions. The absence of rules qualifying values of <code>(ref A)</code> in any other way cause any other attempts to type values as <code>(ref A)</code> to fail.</p>\n\n<p>It is now easy to define the Shen versions of the <code>readref</code> and <code>writeref</code> functions.</p>\n\n<pre><code>(define &lt;-r\n   { (ref A) --&gt; A }\n   R -&gt; (thaw (fst R)))\n\n(define r-&gt;\n   { (ref A) --&gt; A --&gt; unit }\n   R X -&gt; ((snd R) X))</code></pre>\n\n<p>The functions <code>fst</code> and <code>snd</code> project onto the first and second elements of an ordered pair respectively.</p>\n\n<p>The complete Shen source for the exercise is <a href=\"https://github.com/mthom/shen-reference-cells/blob/master/ref-cells.shen\">here</a>.</p>\n\n<h2 id=\"example-block-scanner\">Example: block-scanner</h2>\n\n<p>As an example of reference cells, we adapt the text block scanner closure from Doug Hoyte&rsquo;s book, <a href=\"http://letoverlambda.com/index.cl/guest/chap2.html#sec_6\">Let Over Lambda</a>.</p>\n\n<pre><code>(define char-scanner\n  { string --&gt; (ref string) --&gt; string --&gt; unit }\n  Trig Curr (@s C Str) -&gt; (char-scanner Trig Curr Str) where (= (&lt;-r Curr) \"\")\n  Trig Curr (@s C Str) -&gt; (do (r-&gt; Curr (if (= (hdstr (&lt;-r Curr)) C)\n\t\t\t\t\t       (tlstr (&lt;-r Curr))\n\t\t\t\t\t       Trig))\n\t\t\t      (char-scanner Trig Curr Str))\n  Trig Curr \"\" -&gt; [])\n\n(define block-scanner\n  { string --&gt; string --&gt; boolean }\n  Trig -&gt; (let Curr (ref Trig)\n\t    (/. DataString\n\t\t(do\n\t\t (char-scanner Trig Curr DataString)\n\t\t (= (&lt;-r Curr) \"\")))))\n\n(set *scanner* (block-scanner \"jihad\"))\n((value *scanner*) \"we will start \")\n((value *scanner*) \"the ji\")\n((value *scanner*) \"had tomorrow.\")</code></pre>"))))