((3) 0 () 2 ((p+ #"/home/mark/Projects/Shen/mthom.github.io/_src/posts/2015-06-08-shen-kata-1-type-safe-reference-cells.md" . unix) (p+ #"/home/mark/Projects/Shen/mthom.github.io/_src/posts/2016-10-10-poor-man-s-dynamic-dispatch-with-types-in-shen.md" . unix)) () (h ! (equal) ((p+ #"/home/mark/Projects/Shen/mthom.github.io/_src/posts/2016-10-10-poor-man-s-dynamic-dispatch-with-types-in-shen.md" . unix) f post (u . "Poor man's dynamic dispatch with types in Shen") (? . 1) 1476110472 (p+ #"/home/mark/Projects/Shen/mthom.github.io/blog/2016/10/10/poor-man-s-dynamic-dispatch-with-types-in-shen/index.html" . unix) "/blog/2016/10/10/poor-man-s-dynamic-dispatch-with-types-in-shen/" (u . "2016-10-10T08:27:38") (? . 0) #f (c (u . "shen") c (u . "types") c (u . "reflection")) (u . "\n<p><em>DISCLAIMER: In this post I explore an interesting but ill-advised use of Shen&rsquo;s type system. Nothing in it should be taken as an indication of how to write good Shen.</em></p>") #t (u . "\n<p><em>DISCLAIMER: In this post I explore an interesting but ill-advised use of Shen&rsquo;s type system. Nothing in it should be taken as an indication of how to write good Shen.</em></p>\n<!-- more-->\n\n<p>Historically, a lauded feature of Lisp is its extensive support for runtime introspection. Common Lisp makes it easy to tease out properties of programs as first class values, which is especially useful when customizing the behavior of the language to a particular problem domain. The venerable Common Lisp Object System (CLOS) is reknown in PL circles for its flexibility and dynamism &mdash; its first implementation was written entirely in the core Common Lisp language.</p>\n\n<p>From the perspective of a language designer, the downside of extensive introspection support is that makes it much harder to introduce ways of expressing constraints on code into the language. In this post I want to show how we can enable a fast, type-driven, mostly reliable single dispatch mechanism in Shen.</p>\n\n<h2 id=\"property-lists-and-effectful-programming-in-the-type-checker\">Property lists and effectful programming in the type checker</h2>\n\n<p>One feature Shen exhibits from its Lisp heritage is the property list, or plist. A plist is a way of annotating data onto a symbol, which can be associatively read and modified at that symbol, stored as a list of key/value pairs. In chapter 24 of <a href=\"http://www.gigamonkeys.com/book/\">Practical Common Lisp</a>, Seibel uses plists to control the expansion of a family of macros at compile time. Shen&rsquo;s property lists can be annotated onto any Shen value, and are documented <a href=\"http://www.shenlanguage.org/learn-shen/property_lists.html\">here</a>.</p>\n\n<p>We&rsquo;ll begin by providing a typed version of Common Lisp&rsquo;s <code>type-of</code> function. To do this we&rsquo;ll exploit the fact that we have at our disposal most (all?) of the Shen language from within the sequent rules written in any <code>datatype</code> clause.</p>\n\n<p>Since Shen is a Lisp, we also have the home advantage of homoiconicity. This means we can intercept any datum put out by the type checker &mdash; itself a Shen value &mdash; and do whatever we like with it in the course of checking that a value inhabits a type.</p>\n\n<p>So, while verifying that a value <code>X</code> inhabits a type <code>A</code>, we&rsquo;ll annotate <code>X</code>&rsquo;s property list with a representation of its type <code>A</code> at the key type-rep. We&rsquo;ll reference the value of type-rep when we add dynamic dispatch, but first we need to decide on a mode of representation. For type-reps, we&rsquo;ll use Shen strings.</p>\n\n<pre><code>(define string-concat\n  []  -&gt; \"\"\n  [S] -&gt; S\n  [S | Ss] -&gt; (@s S \" \" (string-concat Ss)))\n\n(define type-&gt;string  \n  Xs  -&gt; \"()\" where (empty? Xs)\n  Xs  -&gt; (@s \"(\" (string-concat (map type-&gt;string Xs)) \")\") where (cons? Xs)\n  Str -&gt; (make-string \"~A\" Str))</code></pre>\n\n<p>A brief overview of the predicates in the <code>where</code> clauses: <code>empty?</code> checks for an empty list, <code>cons?</code> for a non-empty list. <code>make-string</code> writes a value to a string using the Fortran formatting notation for strings.</p>\n\n<p><code>string-concat</code> is a simple utility function for concatenating a list of strings together. Adding types, these functions become</p>\n\n<pre><code>(define string-concat\n  { (list string) --&gt; string }\n  []  -&gt; \"\"\n  [S] -&gt; S\n  [S | Ss] -&gt; (@s S \" \" (string-concat Ss)))\n\n(define type-&gt;string\n  { A --&gt; string }\t\n  Xs  -&gt; \"()\" where (empty? Xs)\n  Xs  -&gt; (@s \"(\" (string-concat (map type-&gt;string Xs)) \")\") where (cons? Xs)\n  Str -&gt; (make-string \"~A\" Str))</code></pre>\n\n<p>To support the polymorphism of <code>type-&gt;string</code>, we add a verified type on <code>cons?</code>. For any <code>where Property</code> clause, Shen automatically introduces the axiom <code>Property : verified</code> into the type theory, which a Shen programmer can exploit to type values on a case-driven basis.</p>\n\n<p>Having verified that <code>(cons? Xs)</code> returns true, we want the type checker to deduce that <code>Xs</code> is a non-empty homogeneous list of values with type <code>A</code>. This is done in the rule</p>\n\n<pre><code>(datatype verified-types-for-cons\n  _______________________________________\n  (cons? Xs) : verified &gt;&gt; Xs : (list A);)</code></pre>\n\n<p>The type theory for type-reps is as follows.</p>\n\n<pre><code>(datatype type-reps\n  ______________________________________________\n  X : (type-rep A) &gt;&gt; (get X type-rep) : string;\n\n  let Tag (put (eval X) type-rep (type-&gt;string A))\n  ________________________________________________\n  (tag-value-with-rep X A);\n\n  X : A; (tag-value-with-rep X A);\n  ________________________________\n  X : (mode (type-rep A) -);)</code></pre>\n\n<p>We&rsquo;ll run down the rules from the top. We consider that any value <code>X</code> of type <code>A</code> represents the type of <code>A</code>; the type <code>(type-rep A)</code> is nothing other than the type <code>A</code>.</p>\n\n<p>The first rule says that if the value <code>X</code> represents <code>A</code>, it is annotated with the representation of <code>A</code> at the key type-rep in its plist, a string.</p>\n\n<p>The second rule does the work of annotating the plist with the string representation of <code>A</code> at the key type-rep. Shen values get mangled slightly in the type checker, but the mangling can be overcome using the <code>eval</code> function.</p>\n\n<p>The third and final rule checks that <code>X</code> is of type <code>A</code> before firing the clause that annotates the plist of <code>X</code> appropriately. The <code>mode\n... -</code> wrapper is there to prevent the type checker from entering an infinite loop upon encountering some of the more complicated (ie. polymorphic) types native to Shen.</p>\n\n<p>We are finally ready to give the definition of <code>type-of</code>.</p>\n\n<pre><code>(define type-of\n  { (type-rep A) --&gt; string }\n  X -&gt; (get X type-rep))</code></pre>\n\n<p>And that&rsquo;s it. All the heavy lifting is done in the type checker. We can test the operation of <code>type-of</code> on values of various types.</p>\n\n<pre><code>(36+) (type-of 3)\n\"number\" : string\n\n(37+) (type-of \"a string\")\n\"string\" : string\n\n(38+) (type-of false)\n\"boolean\" : string\n\n(39+) (type-of (@p 3 false [1 2 3] (@v (@v symbols are present &lt;&gt;) &lt;&gt;)))\n\"(number * (boolean * ((list number) * (vector (vector symbol)))))\" : string\n\n(40+) (type-of str)\n\"(Var17 --&gt; string)\" : string</code></pre>\n\n<p>The function <code>str</code> has the polymorphic type <code>(A --&gt; string)</code>, but here a skolemized variable <code>Var17</code> is leaked out of the type checker. Obviously this poses a serious caveat to dynamic dispatch on polymorphic types. We should be more careful in defining <code>type-&gt;string</code> after deciding on a format for polymorphic type representation. This seems a job for the (Shen and human) reader and Shen Prolog.</p>\n\n<h2 id=\"generic-type-verification\">Generic type verification</h2>\n\n<p>What we&rsquo;ve developed is a semi-elegant way of implementing generic verified types. Remember that we had to introduce a special rule for verifying homogeneous lists in <code>where</code> clauses. If we have to do the same for every type we might want to verify in the future, we will quickly overburden the type checker with many ad-hoc rules.</p>\n\n<p>Fortunately, we can leverage <code>type-of</code> to avoid that, at least when dealing with non-polymorphic types.</p>\n\n<pre><code>(define has-type?\n  { (type-rep A) --&gt; string --&gt; boolean }\n  X Type -&gt; (= (type-of X) Type))\n\n(datatype generic-verification  \n  ______________________________________\n  (has-type? X Str) : verified &gt;&gt; X : A;)</code></pre>\n\n<p><code>has-type?</code> checks that <code>X</code> has the type described in the string, by extracting its type representation from <code>type-of</code>. The rule in <code>generic-verification</code> proves that <code>X</code> has type <code>A</code> by appealing to the truth of of <code>has-type?</code> on <code>X</code> and its purported representation <code>Str</code>.</p>\n\n<p>Now we have type verification &ldquo;for free&rdquo;, at least on arbitrary concrete types, as demonstrated in the stupid and useless function <code>arbitrary-messages</code>.</p>\n\n<pre><code>(define arbitrary-messages\n  { (type-rep A) --&gt; string }\n  X -&gt; (let Y (+ X X) (str Y)) where (has-type? X \"number\")\n  X -&gt; (let Y (@s X X X) Y) where (has-type? X \"string\")\n  X -&gt; (@s \"passed a \" (type-of X)))</code></pre>\n\n<p>Note that <code>X</code> is being typed as a number, as a string, etc. in the each of the adjoining clauses, and is treated accordingly. What we&rsquo;ve created is essentially a limited but type safe version of Common Lisp&rsquo;s <code>typecase</code> macro, without delving into macrology.</p>\n\n<h1 id=\"opportunities-and-shortcomings\">Opportunities and Shortcomings</h1>\n\n<p>We&rsquo;ve mentioned the difficulty in dealing with polymorphic types, but another major shortcoming is that Shen&rsquo;s type system is simply too powerful for this mechanism to work well across all applications. Shen places no restrictions on the number of types or the relation among types that any value may belong to.</p>\n\n<p>On the bright side, a technique like this could serve as the basis for some form of automatic type-driven single dispatch; think Haskell&rsquo;s typeclasses.</p>")) ((p+ #"/home/mark/Projects/Shen/mthom.github.io/_src/posts/2015-06-08-shen-kata-1-type-safe-reference-cells.md" . unix) f post (u . "Shen Kata #1: Type-safe reference cells") (? . 0) 1438802895 (p+ #"/home/mark/Projects/Shen/mthom.github.io/blog/2015/06/08/shen-kata-1-type-safe-reference-cells/index.html" . unix) "/blog/2015/06/08/shen-kata-1-type-safe-reference-cells/" (u . "2015-06-08T19:38:12") #f (? . 1) (c (u . "shen") c (u . "currying") c (u . "reference cells") c (u . "types") c (u . "vectors")) (u . "\n<p>Unlike many other eager, statically typed functional languages that emphasize computing with immutable values, Shen lacks native support for reference cells. Let&rsquo;s add our own.</p>") #t (u . "\n<p>Unlike many other eager, statically typed functional languages that emphasize computing with immutable values, Shen lacks native support for reference cells. Let&rsquo;s add our own.</p>\n<!-- more-->\n\n<h2 id=\"first-class-locally-scoped-mutable-values\">First-class, locally scoped mutable values</h2>\n\n<p>We can think of a reference cell as a box containing a pointer to a value of any initial type. In ML family languages, reference cells are associated to interfaces similar to that of the Standard ML signature</p>\n\n<pre><code>signature REF =\nsig\n  type 'a ref\n  val ref : 'a -&gt; 'a ref\n  val writeref : 'a ref -&gt; 'a -&gt; ()\n  val readref : 'a ref -&gt; 'a\nend</code></pre>\n\n<p><code>'a ref</code> is the type of a reference cell, where the ML type <code>'a</code> is the type of its contents. <code>ref</code> creates a reference cell containing its parameter value, <code>writeref</code> replaces the contents of a reference cell with a value of the annotated type of that cell, and <code>readref</code> extracts the contents of a cell.</p>\n\n<p>A write made to a reference cell is propagated to all other data structures containing that cell, which is itself an immutable value. In that sense, reference cells are first-class, locally scoped mutable values of the sort we&rsquo;re accustomed to using in imperative languages.</p>\n\n<p>As in imperative languages, they require a kind of temporal reasoning that is safely neglected when dealing only with immutable values, which is one of the stronger selling points of purely functional languages.</p>\n\n<p>Why bother with reference cells then? At times, the use of mutation can&rsquo;t be avoided, usually for the sake of efficiency. Some data structures lack fast, purely functional implementations. Others are self-referential and can&rsquo;t otherwise be implemented without resorting to laziness, which comes with its own pitfalls and limitations.</p>\n\n<h2 id=\"shen-lacks-reference-cells\">Shen lacks reference cells</h2>\n\n<p>If Shen provided reference cells natively, there would be no reason to add our own. Any candidate for an ad-hoc reference cell in Shen would have to support mutation already. Shen provides mutable values in two principal ways, through vectors and through global assignments.</p>\n\n<p>Global assignments are not locally scoped, since they&rsquo;re accessible from anywhere in a Shen program if the name of the assignment is known.</p>\n\n<p>Shen vectors are first-class, mutable, homogenous containers with a native type theory in line with what we want for ref types, apeing the example of ML. Vectors have the additional property that they may be grown and shrunk an element at a time from the head. In contrast, a reference cell must refer to a single location in memory that persists with the cell, which is to say that an unfettered vector representation allows the programmer to violate core semantic assumptions behind the creation and use of reference cells.</p>\n\n<h2 id=\"a-shen-implementation\">A Shen implementation</h2>\n\n<p>This suggests we should start with vectors as a data representation, and constrain them somehow. One approach is to close two functions over a single cell vector containing an initial value of type <code>A</code>. This prevents the user of the reference cell from accessing the internal vector representation by any means other than that afforded by the two functions, which we will implement as a getter/setter pair. Following the types in the ML signature, we obtain type signatures for these functions,</p>\n\n<p>the getter, <code>ref-reader : (one-cell-vector A) --&gt; (lazy A)</code></p>\n\n<p>and the setter, <code>ref-writer : (one-cell-vector A) --&gt; A --&gt; unit</code>.</p>\n\n<p><code>ref-reader</code>, given a one-cell vector, returns a value of type <code>(lazy\nA)</code>, whose semantics are identical to a function that takes no arguments.</p>\n\n<p><code>ref-writer</code> writes a value of type <code>A</code> to a one-cell vector.</p>\n\n<p>Natively, Shen has a vector type <code>(vector A)</code>, which types a vector of elements of type <code>A</code>. We have to define the <code>(one-cell-vector A)</code> type ourselves, which we do using the sequent rules</p>\n\n<pre><code> (datatype one-cell-vector\n   X : A;\n   ________________________________\n   (@v X &lt;&gt;) : (one-cell-vector A);\n\n   __________________________________________\n   V : (one-cell-vector A) &gt;&gt; V : (vector A);)</code></pre>\n\n<p>Here we give two rules of inference. The first says that a Shen expression matching the template <code>(@v X &lt;&gt;)</code> can be inferred to be of type <code>(one-cell-vector A)</code> if the subexpression <code>X</code> can be inferred to be of type <code>A</code>, where <code>A</code> is a type variable and hence may be substituted for any Shen type (type symbols titled in lower case name concrete types).</p>\n\n<p>The second rule is subtly different. It says that, if it has been proven that a Shen expression <code>V</code> is of type <code>(one-cell-vector A)</code>, (really, <code>V</code> is a template that may be substituted for any Shen expression), then <code>V</code> has the type <code>(vector A)</code>.</p>\n\n<p>These rules stringently constrain the number of ways in which we can generate elements of <code>(one-cell-vector A)</code>. Either we&rsquo;ve called a type-checked function that returns a value of that type, or we&rsquo;ve generated one directly using the <code>(@v X &lt;&gt;)</code> template, where <code>X</code> is an expression producing a value of type <code>A</code>. We could easily enrich the type theory to allow other semantically valid ways of generating one cell vectors, but for our purposes these rules suffice.</p>\n\n<p>The unit type is pre-defined in Shen, and is uninhabited (no values have the type unit by default). We add our own.</p>\n\n<pre><code>(datatype unit-type\n __________\n [] : unit;)</code></pre>\n\n<p>Equipped with the necessary types, we define the <code>ref-reader</code> and <code>ref-writer</code> functions.</p>\n\n<pre><code>(define ref-reader\n  { (one-cell-vector A) --&gt; (lazy A) }\n  R -&gt; (freeze (&lt;-vector R 1)))\n\n(define ref-writer\n  { (one-cell-vector A) --&gt; A --&gt; unit }\n  R X -&gt; (do (vector-&gt; R 1 X) []))</code></pre>\n\n<p><code>ref-reader</code> suspends (&ldquo;freezes&rdquo;) a computation on a one cell vector <code>R</code>, which reads the value of that cell whenever the computation is thawed (Shen vectors are 1-indexed).</p>\n\n<p><code>ref-writer</code> sequences two expressions in a <code>do</code> form. The first writes the value <code>X</code> to the cell of <code>R</code>, the second evaluates to unit.</p>\n\n<p>We now implement <code>ref</code>, again in keeping with the type given in the ML signature.</p>\n\n<pre><code>(define ref\n   { A --&gt; (ref A) }\n   X -&gt; (let V (@v X &lt;&gt;)\n\t  (@p (ref-reader V) (ref-writer V))))</code></pre>\n\n<p>In Shen, all functions are curried by default, so that the function <code>(ref-writer V)</code> has type <code>A --&gt; unit</code>. <code>(ref A)</code> is defined in the datatype</p>\n\n<pre><code>(datatype ref-types\n   V : (one-cell-vector A);\n   _____________________________________________\n   (@p (ref-reader V) (ref-writer V)) : (ref A);\n\n   _____________________________________________\n   R : (ref A) &gt;&gt; R : ((lazy A) * (A --&gt; unit));)</code></pre>\n\n<p>Since in the context of the definition of <code>ref</code>, we can prove that the expression bound to <code>V</code> is a one-cell vector, it follows by the first rule that the ordered pair <code>(@p (ref-reader V) (ref-writer V))</code> inhabits the type <code>(ref A)</code>.</p>\n\n<p>The second rule says that a value <code>R</code> known to be of type <code>(ref A)</code> is an ordered pair in which the first element has type <code>(lazy A)</code> and the second type <code>(A --&gt; unit)</code>.</p>\n\n<p>And that is all. The type rules guarantee that any value proved to be of type <code>(ref A)</code> is an ordered pair of the reader and writer types, closing over a common one-cell vector, where the reader and writer functions are generated using the <code>ref-reader</code> and <code>ref-writer</code> functions. The absence of rules qualifying values of <code>(ref A)</code> in any other way cause any other attempts to type values as <code>(ref A)</code> to fail.</p>\n\n<p>It is now easy to define the Shen versions of the <code>readref</code> and <code>writeref</code> functions.</p>\n\n<pre><code>(define &lt;-r\n   { (ref A) --&gt; A }\n   R -&gt; (thaw (fst R)))\n\n(define r-&gt;\n   { (ref A) --&gt; A --&gt; unit }\n   R X -&gt; ((snd R) X))</code></pre>\n\n<p>The functions <code>fst</code> and <code>snd</code> project onto the first and second elements of an ordered pair respectively.</p>\n\n<p>The complete Shen source for the exercise is <a href=\"https://gist.github.com/mthom/d433b7fdd1455dbec24d\">here</a>.</p>\n\n<h2 id=\"example-block-scanner\">Example: block-scanner</h2>\n\n<p>As an example of reference cells, we adapt the text block scanner closure from Doug Hoyte&rsquo;s book, <a href=\"http://letoverlambda.com/index.cl/guest/chap2.html#sec_6\">Let Over Lambda</a>.</p>\n\n<pre><code>(define char-scanner\n  { string --&gt; (ref string) --&gt; string --&gt; unit }\n  Trig Curr (@s C Str) -&gt; (char-scanner Trig Curr Str) where (= (&lt;-r Curr) \"\")\n  Trig Curr (@s C Str) -&gt; (do (r-&gt; Curr (if (= (hdstr (&lt;-r Curr)) C)\n\t\t\t\t\t       (tlstr (&lt;-r Curr))\n\t\t\t\t\t       Trig))\n\t\t\t      (char-scanner Trig Curr Str))\n  Trig Curr \"\" -&gt; [])\n\n(define block-scanner\n  { string --&gt; string --&gt; boolean }\n  Trig -&gt; (let Curr (ref Trig)\n\t    (/. DataString\n\t\t(do (char-scanner Trig Curr DataString)\n\t\t    (= (&lt;-r Curr) \"\")))))\n\n(set *scanner* (block-scanner \"jihad\"))\n\n((value *scanner*) \"we will start \")\n((value *scanner*) \"the ji\")\n((value *scanner*) \"had tomorrow.\")</code></pre>"))))